# Redis

redis是内存数据库，如果不能将内存中的数据库状态保存到磁盘，一旦服务器的进程退出，服务器中的内存数据库状态也会消失，所以redis提供了持久化功能

> RDB (Redis Database)

在指定的时间间隔内将内存中的数据集体快照刺蛾如此盘，恢复的时候将快照文件直接读到内存中。

redis会单独创建一个子进程来进行持久化，会将数据写入到一个临时文件中，持久化进程都结束了，再用这个临时文件替换上次持久化好的文件。这个过程中主进程是不进行任何I/O操作的，这就确保了极高的性能。如果需要进行大规模的恢复，且对于数据恢复的完整性不是非常敏感，那么RDB方式要比AOF方式更加高效。

Redis默认的持久化方式就是RDB，一般情况下不需要修改这个配置。

RDB的缺点是最后一次持久化的数据可能会丢失。

RDB保存的文件是dump.rdb

REB的触发规则：

    1. save的规则满足的情况下，会自动触发规则，比如在配置文件中设置 save 60 5，在一分钟内发生五次数据变化，就触发rdb规则生成rdb文件
    2. 执行flushall命令，也会触发rdb规则，生成rdb文件
    3. 退出redis进程的时候也会触发rdb规则，生成rdb文件

如何恢复rdb文件：

    1. 只需要将rdb文件放到redis的启动目录下就可以了，redis启动的时候会自动检查dump.rdb文件恢复数据
    ~~~redis
    127.0.0.1:6379> config get dir # 查看启动目录
    1) "dir"
    2) "/usr/local/redis" # 如果在这个目录下存在dump.rdb，那么redis启动就会自动恢复其中的数据
    ~~~
    
REB的优缺点：

    优点：
    1. 适合大规模数据恢复
    2. 适合对数据完整性要求不高
    
    缺点：
    3. 需要一定的时间间隔进行操作，如果redis意外宕机，最后一次修改的数据就有可能会丢失。
    4. fork进程的时候，会占用一定的内存空间
    
    因此在生产环境有需要的话需要对rdb文件做备份。
    
> AOF(Append Only File：追加文件)
    
将我们所有的命令都记录下来，相当于一个history，恢复的时候把这个文件中的命令全部执行一遍。
    
一日志的形式记录每个写的操作，将redis执行过的所有命令（不包括读的操作），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据。也就是说，redis启动就会根据日志文件的内容将写命令从前往后执行一遍完成数据恢复。
    
AOF保存的文件是appendonly.aof文件
    
redis默认是不开启AOF的，需要的话必须修改配置文件手动开启 `appendonly yes`，重启 redis服务就可以生效了。如果aof文件被破环或者文件内容有误，redis重启就会失败，对此redis提供了一个工具，这时候可以使用redis启动目录下的`redis-check-aof —-fix appendonly.aof`文件检测修复。如果文件正常，重启就可以直接恢复了。

AOF的重写规则：
~~~bash
# Specify a percentage of zero in order to disable the automatic AOF
# rewrite feature.

auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
~~~

如果aof文件大于64mb，就会fork一个新的进程来讲文件进行重写。aof默认是文件无限追加，文件越来越大就会产生重写。

AOF优点和缺点：
    优点：
    1. 每一次修改都同步，数据的完整性更好
    2. 如果配置每秒同步，可能会丢失一秒的数据
    3. 如果配置从不同步，效率更高
    缺点：
    4. 相对于数据文件来说。aof远远大于rdb，数据修复的速度也比rdb慢
    5. aof运行效率也要比rdb慢，因此redis默认的持久化配置是rdb。

> 扩展

1. 如果只做缓存，只希望数据在服务器运行的时候存在，可以不做任何持久化
2. 同时开启两种持久化，redis重启会优先载入aof文件来回复数据，因为通常情况下aof保存的数据比rdb更加完整。但是aof文件存在重写，效率不高，这时候rdb的存在会更加保险。
3. 性能建议：
    * 因为rdb只用作后备用途，建议只在Slave（从机）上持久化rdb文件，而且15分钟备份一次即可，只保留`save 900 1`这条规则
    * 如果开启aof，好处是最恶劣的情况下也之后丢不超过两秒的数据，代价一是带来了持续的I/O，二是aof重写到新文件会造成不可避免的阻塞。
    * 如果不开启aof，只靠Master-Slave Repllcation（主存复制）实现高可用也行，可以生一大笔I/O，同时避免了重写aof。但是如果Master和Slave同时宕机（断电），会丢失十几分钟的数据，启动脚本会比较两个Master/Slave中的rdb文件，载入较新的，微博就是这种架构。
    
